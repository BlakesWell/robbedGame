%Properties()
{
    UI_SSRHeader("# Screen Space Reflections", Int) = 0
    UI_SSRDocs("[This module has documentation](https://shaders.orels.sh/docs/configurable-shaders/modules/ssr)", Int) = 0
    [Toggle(SSR)]_SSREnabled("Enable SSR %ForceRenderType(Custom,2501,Transparent,Fade) %EnablePass(GrabPass)", Int) = 0
    _SSRStrength("Strength %ShowIf(SSR)", Range(0,1)) = 1
    [IntRange]_SSRMaxSteps("Maximum Steps %ShowIf(SSR)", Range(1,50)) = 50
    _SSRStep("Step Size %ShowIf(SSR)", Float) = 0.09 
    _SSREdgeFade("Edge Fade %ShowIf(SSR)", Range(0,1)) = 0.1
    _SSRBakedReflectionStrength("Baked Reflection Strength %ShowIf(SSR)", Range(0, 1)) = 1
    UI_SSRInternalsHeader("## Internals", Int) = 0
    _SSRLRad("Intersection (L) %ShowIf(SSR)", Float) = 0.02
    _SSRSRad("Intersection (R) %ShowIf(SSR)", Float) = 0.02
    _SSRNoiseTexture("Noise Texture > %RequiredTexture(@/SSRNoise.png) %ShowIf(SSR)", 2D) = "black" {}
}

%Variables()
{
    float _VRChatMirrorMode;
    float4 _ORLGrabTexture_TexelSize;
    float4 _SSRNoiseTexture_TexelSize;
    half _SSRStrength;
    int _SSRMaxSteps;
    float _SSRStep;
    float _SSRLRad;
    float _SSRSRad;
    half _SSREdgeFade;
    half _SSRBakedReflectionStrength;
}

%Textures()
{
    TEXTURE2D_X(_ORLGrabTexture);
    SAMPLER(sampler_ORLGrabTexture);
    TEXTURE2D(_SSRNoiseTexture);
    SAMPLER(sampler_SSRNoiseTexture);
}

%ShaderFeatures()
{
    #pragma shader_feature_local_fragment SSR
}

%PrePasses()
{
    GrabPass { 
        Tags { "LightMode" = "GrabPass"}
        "_ORLGrabTexture"
    }
}

%ShaderDefines()
{
    #if defined(SSR)
        #define _INTEGRATE_CUSTOMGI_FLEX
        #define NEED_SCREEN_POS
    #endif
}


// These rely on specific textures, so they are defined in the pass functions instead of library
%PassFunctions()
{
    // Based on Mochie's SSR implementation (Based on ERROR.mdl's implementation)
    // https://github.com/MochiesCode/Mochies-Unity-Shaders/
    // Licensed under MIT
    float3 GetBlurredGP(float2 texelSize, float2 uvs, float dim){
        float2 pixSize = 2/texelSize;
        float center = floor(dim*0.5);
        float3 refTotal = float3(0,0,0);
        for (int i = 0; i < floor(dim); i++){
            for (int j = 0; j < floor(dim); j++){
                float4 refl = SAMPLE_TEXTURE2D_X(_ORLGrabTexture, sampler_ORLGrabTexture, float2(uvs.x + pixSize.x*(i-center), uvs.y + pixSize.y*(j-center)));
                refTotal += refl.rgb;
            }
        }
        return refTotal/(floor(dim)*floor(dim));
    }

    float4 ReflectRay(float3 reflectedRay, float3 rayDir, float lRad, float sRad, float step, float noise, const int maxIterations){
        
        #if UNITY_SINGLE_PASS_STEREO
            half x_min = 0.5 * unity_StereoEyeIndex;
            half x_max = 0.5 + 0.5 * unity_StereoEyeIndex;
        #else // SPSI and MultiView work on the full screen
            half x_min = 0.0;
            half x_max = 1.0;
        #endif
        
        reflectedRay = TransformWorldToView(reflectedRay);
        rayDir = TransformWorldToViewDir(rayDir);
        int totalIterations = 0;
        int direction = 1;
        float3 finalPos = 0;

        [loop]
        for (int i = 0; i < maxIterations; i++){
            totalIterations = i;
            float4 spos = GetScreenPosition(TransformWViewToHClip(reflectedRay));
            float2 uvDepth = spos.xy / spos.w;
            UNITY_BRANCH
            if (uvDepth.x > x_max || uvDepth.x < x_min || uvDepth.y > 1 || uvDepth.y < 0){
                break;
            }

            float rawDepth = SampleSceneDepthRGDecoded(uvDepth);
            float linearDepth = Linear01Depth(rawDepth);
            float sampleDepth = -reflectedRay.z;
            float realDepth = linearDepth * _ProjectionParams.z;
            float depthDifference = abs(sampleDepth - realDepth);

            if (depthDifference < lRad){ 
                if (direction == 1){
                    if(sampleDepth > (realDepth - sRad)){
                        if(sampleDepth < (realDepth + sRad)){
                            finalPos = reflectedRay;
                            break;
                        }
                        direction = -1;
                        step = step*0.1;
                    }
                }
                else {
                    if(sampleDepth < (realDepth + sRad)){
                        direction = 1;
                        step = step*0.1;
                    }
                }
            }
            reflectedRay = reflectedRay + direction*step*rayDir;
            step += step*(0.025 + 0.005*noise);
            lRad += lRad*(0.025 + 0.005*noise);
            sRad += sRad*(0.025 + 0.005*noise);
        }
        return float4(finalPos, totalIterations);
    }

    half4 GetSSRColor(float3 worldPos, float3 viewDir, float3 reflDir, float3 worldNormal, float smoothness, half3 albedo, float metallic, float mask, float4 screenPos) {
        float NoR = dot(worldNormal, reflDir);

        bool isInVRMirror = _VRChatMirrorMode == 1;
        bool isInDesktopMirror = _VRChatMirrorMode == 2;

        [branch]
        if ((isInVRMirror || isInDesktopMirror) || NoR < 0 || mask < 0.001) {
            return 0;
        }
        else {

            float4 noiseUvs = screenPos;
            noiseUvs.xy = (noiseUvs.xy * _ORLGrabTexture_TexelSize.zw) / (_SSRNoiseTexture_TexelSize.zw * noiseUvs.w);	
            float4 noiseRGBA = SAMPLE_TEXTURE2D_LOD(_SSRNoiseTexture, sampler_SSRNoiseTexture, noiseUvs.xy,0);
            float noise = noiseRGBA.r;
            
            float3 reflectedRay = worldPos.xyz + (_SSRLRad*_SSRStep/NoR + noise*_SSRStep)*reflDir;
            
            float scatterMult = 0.2;
            float4 scatter = float4(0.5 - noiseRGBA.rgb,0);
            reflDir = normalize(reflDir + scatterMult*scatter*(1-smoothness)*sqrt(NoR));

            float4 finalPos = ReflectRay(reflectedRay, reflDir, _SSRLRad, _SSRSRad, _SSRStep, noise, _SSRMaxSteps);
            float totalSteps = finalPos.w;
            finalPos.w = 1;

            if (!any(finalPos.xyz))
                return 0;
            
            float4 uvs = GetGrabScreenPosition(TransformWViewToHClip(finalPos));
            uvs.xy = uvs.xy / uvs.w;

            #if UNITY_SINGLE_PASS_STEREO || defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
                float xfade = 1;
            #else
                float xfade = smoothstep(0, _SSREdgeFade, uvs.x)*smoothstep(1, 1-_SSREdgeFade, uvs.x); //Fade x uvs out towards the edges
            #endif
            float yfade = smoothstep(0, _SSREdgeFade, uvs.y)*smoothstep(1, 1-_SSREdgeFade, uvs.y); //Same for y
            float lengthFade = smoothstep(1, 0, 2*(totalSteps / _SSRMaxSteps)-1);
        
            float fade = xfade * yfade * lengthFade;

            float blurFac = max(1,min(12, 12 * (-2)*(smoothness-1)));
            float4 reflection = float4(GetBlurredGP(_ORLGrabTexture_TexelSize.zw, uvs.xy, blurFac),1);
            
            reflection.rgb = lerp(reflection.rgb, reflection.rgb*albedo.rgb, metallic);

            float RdotV = dot(reflDir, viewDir);
            reflection.a = NoR*fade*smoothness * _SSRStrength;
            return max(0,reflection);
        }
    }
}

%CustomGI("SSRCustomGI")
{
    void SSRCustomGI(MeshData d, SurfaceData o, float3 reflDir, inout half3 indirectSpecular)
    {
        #if defined(SSR)
        half4 ssrResult = GetSSRColor(d.worldSpacePosition, d.worldSpaceViewDir, reflDir, o.Normal, o.Smoothness, o.Albedo, o.Metallic, 1, d.screenPos);
        indirectSpecular *= max(_SSRBakedReflectionStrength, 0.0001);
        indirectSpecular = lerp(indirectSpecular, ssrResult.rgb, ssrResult.a);
        #endif
    }
}