%ShaderName("orels1/VFX/Clouds")
%LightingModel("@/LightingModels/VFX")
%CustomEditor("ORL.ShaderInspector.InspectorGUI")
%TemplateFeatures("ShadowCaster")


%Properties()
{
    UI_CloudsDocs("[This shader has documentation](https://shaders.orels.sh/docs/vfx/clouds)", Int) = 0

    UI_ShadingHeader("# Shading", Int) = 1
    [ToggleUI]_EnableDepthBlending("Enable Depth Blending", Int) = 1
    _DepthTransp("Depth Transparency %ShowIf(_EnableDepthBlending)", Float) = 36
    [ToggleUI]_CastShadows("Cast Shadows", Int) = 0
    [Toggle(APPLY_SHADING)]_ApplyShading("Apply Shading", Int) = 0
    _ShadeRamp("Shade Ramp %ShowIf(APPLY_SHADING) %Gradient()", 2D) = "grayscaleRamp" {}
    _Tint("Tint %ShowIf(APPLY_SHADING)", Color) = (1,1,1,1)
    _ShadowColor("Shadow Color %ShowIf(APPLY_SHADING)", Color) = (0,0,0,1)
    [Toggle(RECALCULATE_NORMALS)]_RecalculateNormals("Recalculate Normals %ShowIf(APPLY_SHADING)", Int) = 0
    _NormalPrecision("Normal Precision %ShowIf(APPLY_SHADING && RECALCULATE_NORMALS)", Float) = 0.1
    [ToggleUI]_HeightGradient("Add Height Gradient", Int) = 0
    [Enum(Local Space, 0, World Space, 1)]_HeightGradientSpace("Height Gradient Space %ShowIf(_HeightGradient)", Int) = 0
    _ColorBottom("Color Bottom %ShowIf(_HeightGradient)", Color) = (0.5680403, 0.5980207, 0.6509434, 1)
    _ColorTop("Color Top %ShowIf(_HeightGradient)", Color) = (0.8066038, 0.9495488, 1, 1)
    _HeightBottom("Height Bottom %ShowIf(_HeightGradient)", Float) = 0.12
    _HeightTop("Height Top %ShowIf(_HeightGradient)", Float) = 1

    UI_DetailsHeader("# Details", Int) = 1
    _DetailTexture("Detail Texture >", 2D) = "white" { }
    [HDR]_DetailTextureTint("Tint", Color) = (1,1,1,1)
    _DetailTextureStrength("Strength", Range(0,1)) = 1
    [Enum(World Space, 0, Local Space, 1)]_DetailMappingSpace("Mapping Space", Int) = 0
    _DetailTriplanarBlend("Triplanar Blend", Range(0,2)) = 1
    _DetailScale("Scale", Float) = 1
    [ToggleUI]_DetailFlip90("Flip 90", Int) = 0
    _DetailTextureScroll("Scroll", Vector) = (0,0,0,0)

    UI_NoiseHeader("# Noise", Int) = 1

    [NonModifiableTextureData][NoScaleOffset]_BakedNoiseTex("Noise Tex > %RequiredTexture(@/BakedNoise.png)", 2D) = "white" { }
    [Enum(World Space, 0, Local Space, 1)]_NoiseSpace("Noise Space", Int) = 0
    UI_ExtrusionHeader("## Extrusion", Int) = 0
    [Enum(Normal, 0, World Space, 1)]_ExtrusionMode("Extrusion Mode", Int) = 0
    _ExtrusionDirection("Extrusion Direction %ShowIf(_ExtrusionMode > 0)", Vector) = (0, 1, 0, 1)
    [Toggle(ONLY_TOP)]_OnlyTop("Only Top %ShowIf(_ExtrusionMode > 0)", Int) = 0
    [Enum(None, 0, Texture, 1, Vertex Color, 2)]_ExtrusionMaskMode("Mask Mode", Int) = 0
    _ExtrusionMask("Mask %ShowIf(_ExtrusionMaskMode == 1)", 2D) = "white" {}
    [Enum(UV, 0, Local Space, 1, World Space, 2)] _ExtrusionMaskMappingSpace("Mapping Space %ShowIf(_ExtrusionMaskMode == 1)", Int) =  0
    [Enum(UV1, 0, UV2, 1, UV3, 2, UV4, 3)]_ExtrusionMaskUVChannel("UV Set %ShowIf(_ExtrusionMaskMode == 1 && _ExtrusionMaskMappingSpace == 0)", Int) = 0
    [Enum(X, 0, Y, 1, Z, 2)] _ExtrusionMaskPlanarAxisX("X Axis %ShowIf(_ExtrusionMaskMappingSpace > 0) %CombineWith(_ExtrusionMaskPlanarAxisY)", Int) =  0
    [HideInInspector][Enum(X, 0, Y, 1, Z, 2)] _ExtrusionMaskPlanarAxisY("Y Axis %ShowIf(_ExtrusionMaskMappingSpace > 0)", Int) = 02
    [Enum(R, 0, G, 1, B, 2, A, 3)]_ExtrusionMaskChannel("Mask Channel %ShowIf(_ExtrusionMaskMode > 0)", Int) = 0
    _ExtrusionMaskStrentgh("Mask Strength %ShowIf(_ExtrusionMaskMode > 0)", Range(0, 1)) = 1
   

    UI_Level1Header("## Level 1", Int) = 0
    _L1NoiseScale("Noise Scale", Float) = 1.7
    _L1NoiseStrength("Noise Strength", Float) = 0.67
    _L1NoiseDirection("Noise Direction", Vector) = (-23.98, 0, 24.37, 0)

    UI_Level2Header("## Level 2", Int) = 0
    _L2NoiseScale("Noise Scale", Float) = 3.2
    _L2NoiseStrength("Noise Strength", Float) = 0.7
    _L2NoiseDirection("Noise Direction", Vector) = (-40, 0, -10, 0)

    UI_Level3Header("## Level 3", Int) = 0
    _L3NoiseScale("Noise Scale", Float) = 35.51
    _L3NoiseStrength("Noise Strength", Float) = 0.1
    _L3NoiseDirection("Noise Direction", Vector) = (80, 0, 0, 0)
}

%ShaderFeatures()
{
    #pragma shader_feature_local_vertex ONLY_TOP
    #pragma shader_feature_local APPLY_SHADING
    #pragma shader_feature_local RECALCULATE_NORMALS
}

%ShaderTags()
{
    "Queue" = "Transparent" "RenderType" = "Transparent" "IgnoreProjector" = "True" "ORL_RenderType" = "Fade"
}

%PassModifiers()
{
    Blend SrcAlpha OneMinusSrcAlpha
}

%ShadowPassModifiers()
{
    ZWrite [_CastShadows]
}

%ShaderDefines()
{
    #define EXTRA_V2F_0
    #define EXTRA_V2F_1
}

%Variables()
{
    float _NormalPrecision;
    half4 _Tint;
    half4 _ShadowColor;

    half4 _DetailTexture_TexelSize;
    int _DetailMappingSpace;
    float _DetailScale;
    float4 _DetailTextureScroll;
    half _DetailTextureStrength;
    half4 _DetailTextureTint;
    half _DetailTriplanarBlend;
    int _DetailFlip90;

    int _NoiseSpace;
    half _ExtrusionMode;
    half4 _ExtrusionDirection;
    half _L1NoiseScale;
    half _L1NoiseStrength;
    half4 _L1NoiseDirection;
    half _L2NoiseScale;
    half _L2NoiseStrength;
    half4 _L2NoiseDirection;
    half _L3NoiseScale;
    half _L3NoiseStrength;
    half4 _L3NoiseDirection;

    int _EnableDepthBlending;
    half _DepthTransp;
    half4 _ColorBottom;
    half4 _ColorTop;
    half _HeightBottom;
    half _HeightTop;
    int _HeightGradient;
    int _HeightGradientSpace;

    int _ExtrusionMaskMode;
    int _ExtrusionMaskMappingSpace;
    int _ExtrusionMaskUVChannel;
    int _ExtrusionMaskPlanarAxisX;
    int _ExtrusionMaskPlanarAxisY;
    int _ExtrusionMaskChannel;
    half4 _ExtrusionMask_ST;
    half _ExtrusionMaskStrentgh;

    float4 _BakedNoiseTex_TexelSize;
}

%Textures()
{
    TEXTURE2D(_BakedNoiseTex);
    SAMPLER(sampler_BakedNoiseTex);

    TEXTURE2D(_ExtrusionMask);
    SAMPLER(sampler_ExtrusionMask);

    TEXTURE2D(_ShadeRamp);
    SAMPLER(sampler_ShadeRamp);

    TEXTURE2D(_DetailTexture);
    SAMPLER(sampler_DetailTexture);
}

%LibraryFunctions()
{
    struct CloudNoiseParams
    {
        float noiseScale;
        float3 noiseDirection;
        float noiseStrength;
    };

    struct CloudNoiseMaskingParams
    {
        float4 mask_ST;
        int maskMode;
        int maskUVChannel;
        int maskChannel;
        float maskStrength;
        int mappingSpace;
        int axisX;
        int axisY;
    };

    struct CloudVertexData
    {
        float4 vertex : POSITION;
        float3 normal : NORMAL;
        float4 tangent : TANGENT;
        float4 color : COLOR;
        float4 uv0 : TEXCOORD0;
        float4 uv1 : TEXCOORD1;
        float4 uv2 : TEXCOORD2;
        float4 uv3 : TEXCOORD3;
        UNITY_VERTEX_INPUT_INSTANCE_ID
    };

    float3 CloudExtrusion(
        CloudVertexData v,
        float3 vertexPos,
        float3 wNormal,
        float3 exDir,
        TEXTURE2D_PARAM(bakedNoise, samplerBakedNoise),
        float4 bakedNoiseTexelSize,
        int noiseSpace,
        TEXTURE2D_PARAM(extrusionMask, samplerExtrusionMask),
        CloudNoiseMaskingParams maskingParams,
        CloudNoiseParams noiseL1,
        CloudNoiseParams noiseL2,
        CloudNoiseParams noiseL3
    )
    {
        float3 wPos = noiseSpace ? vertexPos : TransformObjectToWorld(vertexPos);
        float3 pos = wPos.xyz / 100;        

        float3 vertOffset = 0;

        [branch]
        if (maskingParams.maskMode > 0)
        {
            half mask = 1;
            if (maskingParams.maskMode == 1)
            {
                float2 maskUv = v.uv0.xy;
                
                if (maskingParams.mappingSpace == 0)
                {
                    switch (maskingParams.maskUVChannel)
                    {
                        case 1: maskUv = v.uv1.xy; break;
                        case 2: maskUv = v.uv2.xy; break;
                        case 3: maskUv = v.uv3.xy; break;
                    }
                }
                if (maskingParams.mappingSpace > 0)
                {
                    maskUv = float2(
                        lerp(v.vertex[maskingParams.axisX], wPos[maskingParams.axisX], floor(maskingParams.mappingSpace - 1)),
                        lerp(v.vertex[maskingParams.axisY], wPos[maskingParams.axisY], floor(maskingParams.mappingSpace - 1))
                    );
                }

                mask = SAMPLE_TEXTURE2D_LOD(extrusionMask, samplerExtrusionMask, maskUv.xy * maskingParams.mask_ST.xy + maskingParams.mask_ST.zw, 0)[maskingParams.maskChannel];
            } else {
                mask = v.color[maskingParams.maskChannel];
            }

            exDir = lerp(exDir, exDir * mask, maskingParams.maskStrength);
        }

        #if defined(ONLY_TOP)

        if (dot(wNormal, half3(0, 1, 0)) > 0)
        {
            vertOffset += exDir * (0.7 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos * noiseL1.noiseScale + _Time.y * (noiseL1.noiseDirection / 100)) * noiseL1.noiseStrength);
            half3 pos2 = pos * noiseL2.noiseScale;
            pos2.z /= 2;
            vertOffset += exDir * (0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos2 * noiseL2.noiseScale + _Time.y * (noiseL2.noiseDirection / 100)) * noiseL2.noiseStrength);

            half3 pos3 = pos * noiseL3.noiseScale;
            vertOffset += exDir * (0.5 * 0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos3 + _Time.y * (noiseL3.noiseDirection / 100)) * noiseL3.noiseStrength);
            pos3 *= 2.01;
            vertOffset += exDir * (0.5 * 0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos3 + _Time.y * (noiseL3.noiseDirection / 100)) * noiseL3.noiseStrength);
        }

        #else

        vertOffset += exDir * (0.7 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos * noiseL1.noiseScale + _Time.y * (noiseL1.noiseDirection / 100)) * noiseL1.noiseStrength);
        half3 pos2 = pos * noiseL2.noiseScale;
        pos2.z /= 2;
        vertOffset += exDir * (0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos2 * noiseL2.noiseScale + _Time.y * (noiseL2.noiseDirection / 100)) * noiseL2.noiseStrength);

        half3 pos3 = pos * noiseL3.noiseScale;
        vertOffset += exDir * (0.5 * 0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos3 + _Time.y * (noiseL3.noiseDirection / 100)) * noiseL3.noiseStrength);
        pos3 *= 2.01;
        vertOffset += exDir * (0.5 * 0.3 * getBakedNoiseBilinear(TEXTURE2D_ARGS(bakedNoise, samplerBakedNoise), bakedNoiseTexelSize, pos3 + _Time.y * (noiseL3.noiseDirection / 100)) * noiseL3.noiseStrength);

        #endif

        return vertOffset;
    }
}

%ExtraPass("TransparencyPrePass", ExtraPassType.PrePass)
{
    %PassModifiers()
    {
        ZWrite On
        ColorMask 0
        ZTest LEqual
    }

    %Vertex("CloudsVertex")
    {
        void CloudsVertex(inout VertexData v, inout FragmentData o)
        {
            float3 wNormal = normalize(TransformObjectToWorldDir(v.normal, 0.0).xyz);
            float3 exDir = _ExtrusionMode == 0 ? v.normal.xyz : normalize(_ExtrusionDirection.xyz);

            CloudNoiseMaskingParams maskingParams;
            maskingParams.mask_ST = _ExtrusionMask_ST;
            maskingParams.maskMode = _ExtrusionMaskMode;
            maskingParams.maskUVChannel = _ExtrusionMaskUVChannel;
            maskingParams.maskChannel = _ExtrusionMaskChannel;
            maskingParams.maskStrength = _ExtrusionMaskStrentgh;
            maskingParams.mappingSpace = _ExtrusionMaskMappingSpace;
            maskingParams.axisX = _ExtrusionMaskPlanarAxisX;
            maskingParams.axisY = _ExtrusionMaskPlanarAxisY;

            CloudNoiseParams noiseL1;
            noiseL1.noiseScale = _L1NoiseScale;
            noiseL1.noiseDirection = _L1NoiseDirection;
            noiseL1.noiseStrength = _L1NoiseStrength;

            CloudNoiseParams noiseL2;
            noiseL2.noiseScale = _L2NoiseScale;
            noiseL2.noiseDirection = _L2NoiseDirection;
            noiseL2.noiseStrength = _L2NoiseStrength;

            CloudNoiseParams noiseL3;
            noiseL3.noiseScale = _L3NoiseScale;
            noiseL3.noiseDirection = _L3NoiseDirection;
            noiseL3.noiseStrength = _L3NoiseStrength;
            
            float3 vertOffset = CloudExtrusion(v, v.vertex, wNormal, exDir, TEXTURE2D_ARGS(_BakedNoiseTex, sampler_BakedNoiseTex), _BakedNoiseTex_TexelSize, _NoiseSpace, TEXTURE2D_ARGS(_ExtrusionMask, sampler_ExtrusionMask), maskingParams, noiseL1, noiseL2, noiseL3);
            v.vertex.xyz += vertOffset;
        }
    }
}


%Vertex("CloudsVertex")
{
    void CloudsVertex(inout VertexData v, inout FragmentData o)
    {
        float3 wNormal = TransformObjectToWorldDir(v.normal, 0.0).xyz;
        float3 exDir = _ExtrusionMode == 0 ? v.normal.xyz : normalize(_ExtrusionDirection.xyz);

        CloudNoiseMaskingParams maskingParams;
        maskingParams.mask_ST = _ExtrusionMask_ST;
        maskingParams.maskMode = _ExtrusionMaskMode;
        maskingParams.maskUVChannel = _ExtrusionMaskUVChannel;
        maskingParams.maskChannel = _ExtrusionMaskChannel;
        maskingParams.maskStrength = _ExtrusionMaskStrentgh;
        maskingParams.mappingSpace = _ExtrusionMaskMappingSpace;
        maskingParams.axisX = _ExtrusionMaskPlanarAxisX;
        maskingParams.axisY = _ExtrusionMaskPlanarAxisY;

        CloudNoiseParams noiseL1;
        noiseL1.noiseScale = _L1NoiseScale;
        noiseL1.noiseDirection = _L1NoiseDirection;
        noiseL1.noiseStrength = _L1NoiseStrength;

        CloudNoiseParams noiseL2;
        noiseL2.noiseScale = _L2NoiseScale;
        noiseL2.noiseDirection = _L2NoiseDirection;
        noiseL2.noiseStrength = _L2NoiseStrength;

        CloudNoiseParams noiseL3;
        noiseL3.noiseScale = _L3NoiseScale;
        noiseL3.noiseDirection = _L3NoiseDirection;
        noiseL3.noiseStrength = _L3NoiseStrength;
        
        #if defined(RECALCULATE_NORMALS) && defined(APPLY_SHADING)
        {
            float3 vertOffset = CloudExtrusion(
                v, v.vertex, wNormal, exDir,
                TEXTURE2D_ARGS(_BakedNoiseTex, sampler_BakedNoiseTex), _BakedNoiseTex_TexelSize, _NoiseSpace,
                TEXTURE2D_ARGS(_ExtrusionMask, sampler_ExtrusionMask),
                maskingParams, noiseL1, noiseL2, noiseL3
            );
            float3 newVertPos = v.vertex.xyz + vertOffset;
            
            float3 bitangent = cross(v.normal.xyz, v.tangent.xyz);
            
            float3 newTangent = v.vertex.xyz + v.tangent.xyz * _NormalPrecision;
            newTangent = (newTangent
                + CloudExtrusion(
                    v, newTangent, wNormal, exDir,
                    TEXTURE2D_ARGS(_BakedNoiseTex, sampler_BakedNoiseTex), _BakedNoiseTex_TexelSize, _NoiseSpace,
                    TEXTURE2D_ARGS(_ExtrusionMask, sampler_ExtrusionMask),
                    maskingParams, noiseL1, noiseL2, noiseL3
                )
            ) - newVertPos;

            float3 newBitangent = v.vertex.xyz + bitangent.xyz * _NormalPrecision;
            newBitangent = (newBitangent
                + CloudExtrusion(
                    v, newBitangent, wNormal, exDir,
                    TEXTURE2D_ARGS(_BakedNoiseTex, sampler_BakedNoiseTex), _BakedNoiseTex_TexelSize, _NoiseSpace,
                    TEXTURE2D_ARGS(_ExtrusionMask, sampler_ExtrusionMask),
                    maskingParams, noiseL1, noiseL2, noiseL3
                )
            ) - newVertPos;
            
            v.normal.xyz = cross(newTangent, newBitangent);
            v.tangent.xyz = newTangent;
            v.vertex.xyz = newVertPos;
        }
        #else
        {
            float3 vertOffset = CloudExtrusion(v, v.vertex, wNormal, exDir, TEXTURE2D_ARGS(_BakedNoiseTex, sampler_BakedNoiseTex), _BakedNoiseTex_TexelSize, _NoiseSpace, TEXTURE2D_ARGS(_ExtrusionMask, sampler_ExtrusionMask), maskingParams, noiseL1, noiseL2, noiseL3);
            v.vertex.xyz += vertOffset;
        }
        #endif

        o.extraV2F0 = GetScreenPosition(TransformObjectToHClip(v.vertex));
        o.extraV2F0.z = -TransformWorldToView(TransformObjectToWorld(v.vertex)).z;
    }
}


%Fragment("CloudsFragment")
{
    void CloudsFragment(MeshData d, inout SurfaceData o, FragmentData i)
    {
        float sceneZ = LinearEyeDepth(SampleSceneDepth(d.extraV2F0.xy / d.extraV2F0.w));
        float depth = sceneZ - d.extraV2F0.z;   
        depth = saturate(invLerp(0, _DepthTransp, depth));
        depth = lerp(1, depth, _EnableDepthBlending);
        o.Alpha = depth;
        half heightAlpha = saturate(invLerp(_HeightBottom, _HeightTop, _HeightGradientSpace ? d.worldSpacePosition.y : d.localSpacePosition.y));

        #if defined(APPLY_SHADING)
        {
            Light mainLight = GetMainLight(i._ShadowCoord, d.worldSpacePosition, 0..xxxx);

            half3 lightAttenuation = mainLight.shadowAttenuation;
            half3 lightColor = mainLight.color * lerp(1,  lightAttenuation + (1 - lightAttenuation) * _ShadowColor.rgb, _ShadowColor.a);
            float3 lightDir = mainLight.direction;

            half lightNoL = dot(d.worldNormal, lightDir);
            half2 rampUv = half2(lightNoL * 0.5 + 0.5, 0);
            half3 ramp = SAMPLE_TEXTURE2D(_ShadeRamp, sampler_ShadeRamp, rampUv).rgb;
            o.Albedo = ramp * lightColor * _Tint.rgb;
            o.Alpha *= _Tint.a;
            if (_HeightGradient) {
                o.Albedo *= lerp(_ColorBottom, _ColorTop, heightAlpha);
                o.Alpha *= lerp(_ColorBottom.a, _ColorTop.a, heightAlpha);
            }
        }
        #else
        {
            o.Albedo = lerp(_ColorBottom, _ColorTop, heightAlpha);
            o.Alpha *= lerp(_ColorBottom.a, _ColorTop.a, heightAlpha);
        }
        #endif

        [branch]
        if (_DetailTexture_TexelSize.z > 16)
        {
            float3 wsAligned = ((_DetailMappingSpace ? d.localSpacePosition : d.worldSpacePosition) / -_DetailScale);

            wsAligned += (_Time.y % 100000) * _DetailTextureScroll.xyz;

            float2 xyUV = wsAligned.xy;
            float2 zyUV = wsAligned.zy;
            float2 xzUV = wsAligned.xz;


            if (_DetailFlip90)
            {
                xyUV = xyUV.yx;
                zyUV = zyUV.yx;
                xzUV = xzUV.yx;
            }
            
            half4 xySample = SAMPLE_TEXTURE2D(_DetailTexture, sampler_DetailTexture, xyUV);
            half4 zySample = SAMPLE_TEXTURE2D(_DetailTexture, sampler_DetailTexture, zyUV);
            half4 xzSample = SAMPLE_TEXTURE2D(_DetailTexture, sampler_DetailTexture, xzUV);
            
            float3 worldNormal = abs(d.worldNormal);
            worldNormal = saturate(worldNormal - (1 - _DetailTriplanarBlend));
            
            half xNormalMask = saturate(lerp(-1, 1, worldNormal.x));
            half yNormalMask = saturate(lerp(-1, 1, worldNormal.y));
            half zNormalMask = saturate(lerp(-1, 1, worldNormal.z));
            
            half4 detail = lerp(lerp(lerp(0, xzSample, yNormalMask), zySample, xNormalMask), xySample, zNormalMask);
            

            o.Albedo = lerp(o.Albedo, o.Albedo * detail.rgb * _DetailTextureTint.rgb, detail.a * _DetailTextureTint.a * _DetailTextureStrength);
        }

    }
}